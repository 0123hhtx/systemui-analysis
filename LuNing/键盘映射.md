# 键盘映射

- 将键盘按键事件和手柄的摇杆按键事件转换为手机游戏的触摸事件，实现类似PC端的游戏体验。

## 总体设计
- 独立应用，提供键盘映射开启按钮；
- 开启后，在所有应用之上打开透明窗口：BaseView，用于接受所有按键事件；
- 快捷键F12打开半透明按键配置界面：ControlView2，用户可根据游戏需要添加轮盘、按钮控件；点击保存按钮关闭配置界面，并且配置生效；
- 关闭应用，同时关闭BaseView；

## 核心代码
### MainActivity.java
- 初始化mHandler，开启按钮，设置按钮点击事件，打开BaseView；

### ViewManager.java
- 打开BaseView：
``` 
  public void showBase() {
      hideControl();
      // 初始化BaseView
      mBaseView = new BaseView(context);
      windowManager = 
          (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
      // 设置窗口属性
      if (mBaseViewParams == null) {
          mBaseViewParams = new WindowManager.LayoutParams();
          mBaseViewParams.width = MainActivity.screenWidth;
          mBaseViewParams.height = MainActivity.screenHeight;
          mBaseViewParams.gravity = Gravity.TOP | Gravity.LEFT;
          mBaseViewParams.type = 
              WindowManager.LayoutParams.TYPE_SYSTEM_ALERT;
          mBaseViewParams.flags = 
              WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
          mBaseViewParams.format = PixelFormat.RGBA_8888;
      }
      // 添加窗口以展示
      windowManager.addView(mBaseView, mBaseViewParams);
  }
``` 

- 打开配置界面ControlView2，与BaseView同理；

### BaseView.java
- 自定义View，通过WindowManager.addView覆盖在所有应用之上的透明窗口，可以获取所有KeyEvent事件；
- 拦截按键事件，并发送模拟点击；
``` 
@Override
public boolean dispatchKeyEvent(final KeyEvent event) {
    // 接收按键F12，打开ControlView2
        ......
    if (event.getAction() == KeyEvent.ACTION_DOWN
            && event.getRepeatCount() == 0) {
        if (mDirectionKeys.contains(keyCode)) {
            // 按键为轮盘方向键down事件
            if ((mCurrentDirectionX < mCircleCenterX - mDistanceFromCircleToKey)
                || (mCurrentDirectionX > mCircleCenterX + mDistanceFromCircleToKey)
                || (mCurrentDirectionY < mCircleCenterY - mDistanceFromCircleToKey)
                || (mCurrentDirectionY > 
                    mCircleCenterY + mDistanceFromCircleToKey)) 
                mCurrentDirectionX = 0;
                mCurrentDirectionY = 0;
                mPressedDirectionKeyCount = 0;
            }
            mPressedDirectionKeyCount++;
            if (mPressedDirectionKeyCount == 1) {
                // todo down circle center
                mCircleCenterX = mDirectionKeys.get(4);
                mCircleCenterY = mDirectionKeys.get(5);
                mDistanceFromCircleToKey = mDirectionKeys.get(6);
                mCurrentDirectionX = mCircleCenterX;
                mCurrentDirectionY = mCircleCenterY;
            }
            // 处理轮盘点击方向
            if (event.getKeyCode() == mDirectionKeys.get(0)) {
                // 按键对应轮盘方向：左
                mCurrentDirectionX = mCurrentDirectionX - mDistanceFromCircleToKey;
            } else  if (event.getKeyCode() == mDirectionKeys.get(1)) {
                // 按键对应轮盘方向：上
                mCurrentDirectionY = mCurrentDirectionY - mDistanceFromCircleToKey;
            } else  if (event.getKeyCode() == mDirectionKeys.get(2)) {
                // 按键对应轮盘方向：右
                mCurrentDirectionX = mCurrentDirectionX + mDistanceFromCircleToKey;
            } else  if (event.getKeyCode() == mDirectionKeys.get(3)) {
                // 按键对应轮盘方向：下
                mCurrentDirectionY = mCurrentDirectionY + mDistanceFromCircleToKey;
            }
            if (mPressedDirectionKeyCount == 1) {
                // 发送轮盘down和move事件
                processDirectionKeyMapping(mInstrumentation, MotionEvent.ACTION_MOVE, mCurrentDirectionX, 
                                           mCurrentDirectionY, true, mCircleCenterX, mCircleCenterY);
            } else {
                processDirectionKeyMapping(mInstrumentation, MotionEvent.ACTION_MOVE,
                mCurrentDirectionX, mCurrentDirectionY, false, 0, 0);
            }
        } else if (mFunctionKeys.contains(event.getKeyCode())) {
            // 处理功能键down事件
            int index = mFunctionKeys.indexOf(keyCode);
            if (mPressedDirectionKeyCount == 0) {
                processFunctionKeyMapping(mInstrumentation, MotionEvent.ACTION_DOWN,
                ViewManager.mDragViewList.get(index).mWUpX + 45,
                ViewManager.mDragViewList.get(index).mWUpY + 45, false, 0, 0 , 0, 0);
            } else {
                processFunctionKeyMapping(mInstrumentation, MotionEvent.ACTION_DOWN,
                ViewManager.mDragViewList.get(index).mWUpX + 45, ViewManager.mDragViewList.get(index).mWUpY + 45,
                                   true, mCircleCenterX, mCircleCenterY, mCurrentDirectionX, mCurrentDirectionY);
            }
        }
    } else if (event.getAction() == KeyEvent.ACTION_UP) {
        if (mDirectionKeys.contains(event.getKeyCode())) {
        // 处理轮盘方向键up事件
            mPressedDirectionKeyCount--;
            if ((mCurrentDirectionX < mCircleCenterX - mDistanceFromCircleToKey)
                || (mCurrentDirectionX > mCircleCenterX + mDistanceFromCircleToKey)
                || (mCurrentDirectionY < mCircleCenterY - mDistanceFromCircleToKey)
                || (mCurrentDirectionY > mCircleCenterY + mDistanceFromCircleToKey)) {
                 mCurrentDirectionX = 0;
                 mCurrentDirectionY = 0;
                 mPressedDirectionKeyCount = 0;
            }
            // 处理轮盘点击方向
            if (event.getKeyCode() == mDirectionKeys.get(0)) {
                // 按键对应轮盘方向：左
                mCurrentDirectionX = mCurrentDirectionX + mDistanceFromCircleToKey;
            } else  if (event.getKeyCode() == mDirectionKeys.get(1)) {
                // 按键对应轮盘方向：上
                mCurrentDirectionY = mCurrentDirectionY + mDistanceFromCircleToKey;
            } else  if (event.getKeyCode() == mDirectionKeys.get(2)) {
                // 按键对应轮盘方向：右
                mCurrentDirectionX = mCurrentDirectionX - mDistanceFromCircleToKey;
            } else  if (event.getKeyCode() == mDirectionKeys.get(3)) {
                // 按键对应轮盘方向：下
                mCurrentDirectionY = mCurrentDirectionY - mDistanceFromCircleToKey;
            }
            if (mPressedDirectionKeyCount == 0) {
                processDirectionKeyMapping(mInstrumentation, MotionEvent.ACTION_UP,
                mCurrentDirectionX, mCurrentDirectionY, false, 0, 0);
            } else {
                processDirectionKeyMapping(mInstrumentation, MotionEvent.ACTION_MOVE,
                mCurrentDirectionX, mCurrentDirectionY, false, 0, 0);
           }
        } else if (mFunctionKeys.contains(event.getKeyCode())) {
            // 处理功能键
            int index = mFunctionKeys.indexOf(keyCode);
            if (mPressedDirectionKeyCount == 0) {
                processFunctionKeyMapping(mInstrumentation, MotionEvent.ACTION_UP, 
                                          ViewManager.mDragViewList.get(index).mWUpX + 45,                             
                                          ViewManager.mDragViewList.get(index).mWUpY + 45, false, 0, 0 , 0, 0);
            } else {
                processFunctionKeyMapping(mInstrumentation, MotionEvent.ACTION_UP,
                                          ViewManager.mDragViewList.get(index).mWUpX + 45, 
                                          ViewManager.mDragViewList.get(index).mWUpY + 45, true, 
                                          mCircleCenterX, mCircleCenterY , mCurrentDirectionX, mCurrentDirectionY);
            }
        }
    }
    return super.dispatchKeyEvent(event);
}
``` 
- 处理接收到的轮盘方向键：
``` 
public void processDirectionKeyMapping(final Instrumentation in, final int eventType, 
                             final float x, final float y, final boolean needDown,
                             final float downX, final float downY) {
new Thread() {
       @Override
       public void run() {
           super.run();
           long time = SystemClock.uptimeMillis();
           // 模拟点击轮盘方向键
           if (needDown) {
               in.sendPointerSync(MotionEvent.obtain(time, time,
                                 MotionEvent.ACTION_DOWN, downX, downY, 0));
               in.sendPointerSync(MotionEvent.obtain(time, time, eventType, x, y, 0));
           } else {
               in.sendPointerSync(MotionEvent.obtain(time, time, eventType, x, y, 0));
           }
        }
    }.start();
}
``` 
- 处理接收到的功能键：
``` 
  public void processFunctionKeyMapping(final Instrumentation in, final int eventType,
                   final float x, final float y, final boolean needMove, final float downX, 
                   final float downY, final float moveX, final float moveY) {
      new Thread() {
          @Override
          public void run() {
              super.run();
              long time = SystemClock.uptimeMillis();
              // 模拟点击功能键
              if (needMove) {
                  in.sendPointerSync(MotionEvent.obtain(time, time, eventType, x, y, 0));
                  in.sendPointerSync(MotionEvent.obtain(time, time, 
                                    MotionEvent.ACTION_DOWN, downX, downY, 0));
                  in.sendPointerSync(MotionEvent.obtain(time, time, 
                                    MotionEvent.ACTION_MOVE, moveX, moveY, 0));
              } else {
                  in.sendPointerSync(MotionEvent.obtain(time, time, eventType, x, y, 0));
              }
          }
      }.start();
  }
``` 

### ControlView2.java
- 自定义View，键盘映射配置界面，用户可自定义按键映射；
- dispatchKeyEvent方法获取按键KeyEvent，给当前焦点所在控件设置对应的按键：
``` 
  @Override
  public boolean dispatchKeyEvent(KeyEvent event) {
      int keyCode = event.getKeyCode();
      String key = null;
      if (mIsFunctionKey) {
          if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
              if (event.getSource() == (InputDevice.SOURCE_GAMEPAD | InputDevice.SOURCE_KEYBOARD)
                  | event.getSource() == InputDevice.SOURCE_JOYSTICK) {
                  key = MainActivity.mKeyMap.get(keyCode);
                  if (key != null) {
                      ViewManager.mDragViewList.remove(mCurrentView);
                      mViewGroup.removeView(mCurrentView);
                  }
              } else if (event.getSource() == InputDevice.SOURCE_KEYBOARD) {
                  boolean isPrintingKey = event.getKeyCharacterMap().isPrintingKey(keyCode);                  
                  ViewManager.mDragViewList.remove(mCurrentView);
                  mViewGroup.removeView(mCurrentView);
                  if (isPrintingKey) {
                      key = String.valueOf((char) event.getUnicodeChar()).toUpperCase();
                  } else {
                      key = keyCode + "";
                  }
              }
              if (key != null) {
                  DragView newDragView = createNewDragView(key, mCurrentView.mWUpX, mCurrentView.mWUpY);
                  newDragView.keyCode = keyCode;
                  ViewManager.mDragViewList.add(newDragView);
             }
          }
      } else if (mIsDirectionKey) {
          if (event.getSource() == (InputDevice.SOURCE_GAMEPAD | InputDevice.SOURCE_KEYBOARD)
                  | event.getSource() == InputDevice.SOURCE_JOYSTICK) {
              key = MainActivity.mKeyMap.get(keyCode);
          } else if (event.getSource() == InputDevice.SOURCE_KEYBOARD) {
              boolean isPrintingKey = event.getKeyCharacterMap().isPrintingKey(keyCode);
              if (isPrintingKey) {
                  key = String.valueOf((char) event.getUnicodeChar()).toUpperCase();
              } else {
                  key = keyCode + "";
              }
          }
          if (key != null) {
              currentTextView.setText(key);
              if (currentTextView == mTvLeft) {
                  ViewManager.mDirectionKeyArr[0] = keyCode;
              } else if (currentTextView == mTvUp) {
                  ViewManager.mDirectionKeyArr[1] = keyCode;
              } else if (currentTextView == mTvRight) {
                  ViewManager.mDirectionKeyArr[2] = keyCode;
              } else if (currentTextView == mTvDown) {
                  ViewManager.mDirectionKeyArr[3] = keyCode;
              }
          }
      }
      if (key != null) {
          Log.i("wwww", key);
      }
      return super.dispatchKeyEvent(event);
  }
  ``` 
  
- DirectionKeyTouchListener类
``` 
  @Override
299         public boolean onTouch(View v, MotionEvent event) {
300             switch (event.getAction()) {
301                 case MotionEvent.ACTION_DOWN:
302                     mIsFunctionKey = false;
303
304                     lastX = (int) event.getRawX();
305                     lastY = (int) event.getRawY();
306                     if (v.getId() != R.id.rl_direction_key) {
307                         mIsDirectionKey = true;
308                         if (currentTextView != null) {
309                             currentTextView.setTextColor(Color.BLACK);
310                         }
311                         currentTextView = (TextView) v;
312                         currentTextView.setTextColor(Color.RED);
313                     } else if (currentTextView != null) {
314                         currentTextView.setTextColor(Color.BLACK);
315                     }
316
317                     v.getLocationOnScreen(mLocations);
318                     mCircleCenterX = mLocations[0] + mBigCircleRadius;
319                     mCircleCenterY = mLocations[1] + mBigCircleRadius;
320                     break;
321                 case MotionEvent.ACTION_MOVE:
322                     if (v.getId() == R.id.rl_direction_key) {
323                         int dX = (int) (event.getRawX() - lastX);
324                         int dY = (int) (event.getRawY() - lastY);
325                         if (mCanResize) {
mIsDrag = true;
327                             mDistance = Math.sqrt(Math.pow(event.getRawX() - mCircleCenterX, 2)
328                                     + Math.pow(event.getRawY() - mCircleCenterY, 2));
329                             float scale = (float) (mDistance / (v.getWidth() / 2));
330                             if ((mBigCircleRadius >= mMinRadius && mBigCircleRadius <= mMaxRadius)
331                                     || (mBigCircleRadius < mMinRadius
332                                             && (mDistance > mBigCircleRadius))
333                                     || (mBigCircleRadius > mMaxRadius
334                                             && (mDistance < mBigCircleRadius))) {
335                                 v.setScaleX(scale);
336                                 v.setScaleY(scale);
337                                 mBigCircleRadius = (int) mDistance;
338                                 mCircleThick = (int) (10 * scale);
339                             }
340                         } else {
341                             newLeft = v.getLeft() + dX;
342                             newTop = v.getTop() + dY;
343                             newRight = v.getRight() + dX;
344                             newBottom = v.getBottom() + dY;
345                             v.layout(newLeft, newTop, newRight, newBottom);
346                         }
347                         lastX = lastX + dX;
348                         lastY = lastY + dY;
349                     }
350                     break;
case MotionEvent.ACTION_UP:
352                     mCanResize = false;
353                     mIsDrag = false;
354                     if (v.getId() == R.id.rl_direction_key) {
355                         //mRlDirectionParams.leftMargin = newLeft;
356                         //mRlDirectionParams.topMargin = newTop;
357                         //mRlDirectionParams.rightMargin = newRight;
358                         //mRlDirectionParams.bottomMargin = newBottom;
359                         //mRlDirectionParams.setMargins(v.getLeft(), v.getTop(), v.getRight(), v.getBottom());
360                         //v.setLayoutParams(mRlDirectionParams);
361                         v.getLocationOnScreen(mLocations);
362                         mCircleCenterX = mLocations[0] + mBigCircleRadius;
363                         mCircleCenterY = mLocations[1] + mBigCircleRadius;
364
365                         int top = mTvUp.getPaddingTop();
366                         int size = (int) mTvUp.getTextSize();
367
368                         mDistanceFromCircleToKey = mBigCircleRadius - top;
369                         ViewManager.mDirectionKeyArr[4] = mCircleCenterX;
370                         ViewManager.mDirectionKeyArr[5] = mCircleCenterY;
371                         ViewManager.mDirectionKeyArr[6] = mDistanceFromCircleToKey;
372                     }
373
374                     break;
375             }
376             return true;
377         }
378     }
``` 
- DirectionKeyHoverListener
``` 
``` 
