# 键盘映射

- 将键盘按键事件和手柄的摇杆按键事件转换为手机游戏的触摸事件，实现类似PC端的游戏体验。

## 总体设计
- 独立应用，提供键盘映射开启按钮；
- 开启后，在所有应用之上打开透明窗口：BaseView，用于接受所有按键事件；
- 快捷键F12打开半透明按键配置界面：ControlView2，用户可根据游戏需要添加轮盘、按钮控件；点击保存按钮关闭配置界面，并且配置生效；
- 关闭应用，同时关闭BaseView；

## 核心代码
### MainActivity.java
- 初始化mHandler，开启按钮，设置按钮点击事件，打开BaseView；

### ViewManager.java
- 打开BaseView：
``` 
  public void showBase() {
      hideControl();
      // 初始化BaseView
      mBaseView = new BaseView(context);
      windowManager = 
          (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
      // 设置窗口属性
      if (mBaseViewParams == null) {
          mBaseViewParams = new WindowManager.LayoutParams();
          mBaseViewParams.width = MainActivity.screenWidth;
          mBaseViewParams.height = MainActivity.screenHeight;
          mBaseViewParams.gravity = Gravity.TOP | Gravity.LEFT;
          mBaseViewParams.type = 
              WindowManager.LayoutParams.TYPE_SYSTEM_ALERT;
          mBaseViewParams.flags = 
              WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
          mBaseViewParams.format = PixelFormat.RGBA_8888;
      }
      // 添加窗口以展示
      windowManager.addView(mBaseView, mBaseViewParams);
  }
``` 

- 打开配置界面ControlView2，与BaseView同理；

### BaseView.java
- 自定义View，通过WindowManager.addView覆盖在所有应用之上的透明窗口，可以获取所有KeyEvent事件；
- 拦截按键事件，并发送模拟点击；
``` 
@Override
public boolean dispatchKeyEvent(final KeyEvent event) {
    // 接收按键F12，打开ControlView2
        ......
    if (event.getAction() == KeyEvent.ACTION_DOWN
            && event.getRepeatCount() == 0) {
        if (mDirectionKeys.contains(keyCode)) {
            // 按键为轮盘方向键down事件
            if ((mCurrentDirectionX < mCircleCenterX - mDistanceFromCircleToKey)
                || (mCurrentDirectionX > mCircleCenterX + mDistanceFromCircleToKey)
                || (mCurrentDirectionY < mCircleCenterY - mDistanceFromCircleToKey)
                || (mCurrentDirectionY > 
                    mCircleCenterY + mDistanceFromCircleToKey)) 
                mCurrentDirectionX = 0;
                mCurrentDirectionY = 0;
                mPressedDirectionKeyCount = 0;
            }
            mPressedDirectionKeyCount++;
            if (mPressedDirectionKeyCount == 1) {
                // todo down circle center
                mCircleCenterX = mDirectionKeys.get(4);
                mCircleCenterY = mDirectionKeys.get(5);
                mDistanceFromCircleToKey = mDirectionKeys.get(6);
                mCurrentDirectionX = mCircleCenterX;
                mCurrentDirectionY = mCircleCenterY;
            }
            // 处理轮盘点击方向
            if (event.getKeyCode() == mDirectionKeys.get(0)) {
                // 按键对应轮盘方向：左
                mCurrentDirectionX = mCurrentDirectionX - mDistanceFromCircleToKey;
            } else  if (event.getKeyCode() == mDirectionKeys.get(1)) {
                // 按键对应轮盘方向：上
                mCurrentDirectionY = mCurrentDirectionY - mDistanceFromCircleToKey;
            } else  if (event.getKeyCode() == mDirectionKeys.get(2)) {
                // 按键对应轮盘方向：右
                mCurrentDirectionX = mCurrentDirectionX + mDistanceFromCircleToKey;
            } else  if (event.getKeyCode() == mDirectionKeys.get(3)) {
                // 按键对应轮盘方向：下
                mCurrentDirectionY = mCurrentDirectionY + mDistanceFromCircleToKey;
            }
            if (mPressedDirectionKeyCount == 1) {
                // 发送轮盘down和move事件
                processDirectionKeyMapping(mInstrumentation, MotionEvent.ACTION_MOVE, mCurrentDirectionX, 
                                           mCurrentDirectionY, true, mCircleCenterX, mCircleCenterY);
            } else {
                processDirectionKeyMapping(mInstrumentation, MotionEvent.ACTION_MOVE,
                mCurrentDirectionX, mCurrentDirectionY, false, 0, 0);
            }
        } else if (mFunctionKeys.contains(event.getKeyCode())) {
            // 处理功能键down事件
            int index = mFunctionKeys.indexOf(keyCode);
            if (mPressedDirectionKeyCount == 0) {
                processFunctionKeyMapping(mInstrumentation, MotionEvent.ACTION_DOWN,
                ViewManager.mDragViewList.get(index).mWUpX + 45,
                ViewManager.mDragViewList.get(index).mWUpY + 45, false, 0, 0 , 0, 0);
            } else {
                processFunctionKeyMapping(mInstrumentation, MotionEvent.ACTION_DOWN,
                ViewManager.mDragViewList.get(index).mWUpX + 45, ViewManager.mDragViewList.get(index).mWUpY + 45,
                                   true, mCircleCenterX, mCircleCenterY, mCurrentDirectionX, mCurrentDirectionY);
            }
        }
    } else if (event.getAction() == KeyEvent.ACTION_UP) {
        if (mDirectionKeys.contains(event.getKeyCode())) {
        // 处理轮盘方向键up事件
            mPressedDirectionKeyCount--;
            if ((mCurrentDirectionX < mCircleCenterX - mDistanceFromCircleToKey)
                || (mCurrentDirectionX > mCircleCenterX + mDistanceFromCircleToKey)
                || (mCurrentDirectionY < mCircleCenterY - mDistanceFromCircleToKey)
                || (mCurrentDirectionY > mCircleCenterY + mDistanceFromCircleToKey)) {
                 mCurrentDirectionX = 0;
                 mCurrentDirectionY = 0;
                 mPressedDirectionKeyCount = 0;
            }
            // 处理轮盘点击方向
            if (event.getKeyCode() == mDirectionKeys.get(0)) {
                // 按键对应轮盘方向：左
                mCurrentDirectionX = mCurrentDirectionX + mDistanceFromCircleToKey;
            } else  if (event.getKeyCode() == mDirectionKeys.get(1)) {
                // 按键对应轮盘方向：上
                mCurrentDirectionY = mCurrentDirectionY + mDistanceFromCircleToKey;
            } else  if (event.getKeyCode() == mDirectionKeys.get(2)) {
                // 按键对应轮盘方向：右
                mCurrentDirectionX = mCurrentDirectionX - mDistanceFromCircleToKey;
            } else  if (event.getKeyCode() == mDirectionKeys.get(3)) {
                // 按键对应轮盘方向：下
                mCurrentDirectionY = mCurrentDirectionY - mDistanceFromCircleToKey;
            }
            if (mPressedDirectionKeyCount == 0) {
                processDirectionKeyMapping(mInstrumentation, MotionEvent.ACTION_UP,
                mCurrentDirectionX, mCurrentDirectionY, false, 0, 0);
            } else {
                processDirectionKeyMapping(mInstrumentation, MotionEvent.ACTION_MOVE,
                mCurrentDirectionX, mCurrentDirectionY, false, 0, 0);
           }
        } else if (mFunctionKeys.contains(event.getKeyCode())) {
            // 处理功能键
            int index = mFunctionKeys.indexOf(keyCode);
            if (mPressedDirectionKeyCount == 0) {
                processFunctionKeyMapping(mInstrumentation, MotionEvent.ACTION_UP, 
                                          ViewManager.mDragViewList.get(index).mWUpX + 45,                             
                                          ViewManager.mDragViewList.get(index).mWUpY + 45, false, 0, 0 , 0, 0);
            } else {
                processFunctionKeyMapping(mInstrumentation, MotionEvent.ACTION_UP,
                                          ViewManager.mDragViewList.get(index).mWUpX + 45, 
                                          ViewManager.mDragViewList.get(index).mWUpY + 45, true, 
                                          mCircleCenterX, mCircleCenterY , mCurrentDirectionX, mCurrentDirectionY);
            }
        }
    }
    return super.dispatchKeyEvent(event);
}
``` 
- 处理接收到的轮盘方向键：
``` 
public void processDirectionKeyMapping(final Instrumentation in, final int eventType, 
                             final float x, final float y, final boolean needDown,
                             final float downX, final float downY) {
new Thread() {
       @Override
       public void run() {
           super.run();
           long time = SystemClock.uptimeMillis();
           // 模拟点击轮盘方向键
           if (needDown) {
               in.sendPointerSync(MotionEvent.obtain(time, time,
                                 MotionEvent.ACTION_DOWN, downX, downY, 0));
               in.sendPointerSync(MotionEvent.obtain(time, time, eventType, x, y, 0));
           } else {
               in.sendPointerSync(MotionEvent.obtain(time, time, eventType, x, y, 0));
           }
        }
    }.start();
}
``` 
- 处理接收到的功能键：
``` 
  public void processFunctionKeyMapping(final Instrumentation in, final int eventType,
                   final float x, final float y, final boolean needMove, final float downX, 
                   final float downY, final float moveX, final float moveY) {
      new Thread() {
          @Override
          public void run() {
              super.run();
              long time = SystemClock.uptimeMillis();
              // 模拟点击功能键
              if (needMove) {
                  in.sendPointerSync(MotionEvent.obtain(time, time, eventType, x, y, 0));
                  in.sendPointerSync(MotionEvent.obtain(time, time, 
                                    MotionEvent.ACTION_DOWN, downX, downY, 0));
                  in.sendPointerSync(MotionEvent.obtain(time, time, 
                                    MotionEvent.ACTION_MOVE, moveX, moveY, 0));
              } else {
                  in.sendPointerSync(MotionEvent.obtain(time, time, eventType, x, y, 0));
              }
          }
      }.start();
  }
``` 

### ControlView2.java
- 自定义View，键盘映射配置界面，用户可自定义按键映射；
- dispatchKeyEvent方法获取按键KeyEvent，给当前焦点所在控件设置对应的按键：
``` 
  @Override
  public boolean dispatchKeyEvent(KeyEvent event) {
      int keyCode = event.getKeyCode();
      String key = null;
      if (mIsFunctionKey) {
          if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
              if (event.getSource() == (InputDevice.SOURCE_GAMEPAD | InputDevice.SOURCE_KEYBOARD)
                  | event.getSource() == InputDevice.SOURCE_JOYSTICK) {
                  key = MainActivity.mKeyMap.get(keyCode);
                  if (key != null) {
                      ViewManager.mDragViewList.remove(mCurrentView);
                      mViewGroup.removeView(mCurrentView);
                  }
              } else if (event.getSource() == InputDevice.SOURCE_KEYBOARD) {
                  boolean isPrintingKey = event.getKeyCharacterMap().isPrintingKey(keyCode);                  
                  ViewManager.mDragViewList.remove(mCurrentView);
                  mViewGroup.removeView(mCurrentView);
                  if (isPrintingKey) {
                      key = String.valueOf((char) event.getUnicodeChar()).toUpperCase();
                  } else {
                      key = keyCode + "";
                  }
              }
              if (key != null) {
                  DragView newDragView = createNewDragView(key, mCurrentView.mWUpX, mCurrentView.mWUpY);
                  newDragView.keyCode = keyCode;
                  ViewManager.mDragViewList.add(newDragView);
             }
          }
      } else if (mIsDirectionKey) {
          if (event.getSource() == (InputDevice.SOURCE_GAMEPAD | InputDevice.SOURCE_KEYBOARD)
                  | event.getSource() == InputDevice.SOURCE_JOYSTICK) {
              key = MainActivity.mKeyMap.get(keyCode);
          } else if (event.getSource() == InputDevice.SOURCE_KEYBOARD) {
              boolean isPrintingKey = event.getKeyCharacterMap().isPrintingKey(keyCode);
              if (isPrintingKey) {
                  key = String.valueOf((char) event.getUnicodeChar()).toUpperCase();
              } else {
                  key = keyCode + "";
              }
          }
          if (key != null) {
              currentTextView.setText(key);
              if (currentTextView == mTvLeft) {
                  ViewManager.mDirectionKeyArr[0] = keyCode;
              } else if (currentTextView == mTvUp) {
                  ViewManager.mDirectionKeyArr[1] = keyCode;
              } else if (currentTextView == mTvRight) {
                  ViewManager.mDirectionKeyArr[2] = keyCode;
              } else if (currentTextView == mTvDown) {
                  ViewManager.mDirectionKeyArr[3] = keyCode;
              }
          }
      }
      if (key != null) {
          Log.i("wwww", key);
      }
      return super.dispatchKeyEvent(event);
  }
  ``` 
  
- DirectionKeyTouchListener类
``` 
  @Override
  public boolean onTouch(View v, MotionEvent event) {
      switch (event.getAction()) {
          case MotionEvent.ACTION_DOWN:
              mIsFunctionKey = false;
              lastX = (int) event.getRawX();
              lastY = (int) event.getRawY();
              if (v.getId() != R.id.rl_direction_key) {
                  mIsDirectionKey = true;
                  if (currentTextView != null) {
                      currentTextView.setTextColor(Color.BLACK);
                  }
                  currentTextView = (TextView) v;
                  currentTextView.setTextColor(Color.RED);
              } else if (currentTextView != null) {
                  currentTextView.setTextColor(Color.BLACK);
              }
              v.getLocationOnScreen(mLocations);
              mCircleCenterX = mLocations[0] + mBigCircleRadius;
              mCircleCenterY = mLocations[1] + mBigCircleRadius;
              break;
          case MotionEvent.ACTION_MOVE:
              if (v.getId() == R.id.rl_direction_key) {
                  int dX = (int) (event.getRawX() - lastX);
                  int dY = (int) (event.getRawY() - lastY);
                  if (mCanResize) {
                      mIsDrag = true;
                      mDistance = Math.sqrt(Math.pow(event.getRawX() - mCircleCenterX, 2)
                                    + Math.pow(event.getRawY() - mCircleCenterY, 2));
                      float scale = (float) (mDistance / (v.getWidth() / 2));
                      if ((mBigCircleRadius >= mMinRadius && mBigCircleRadius <= mMaxRadius)
                          || (mBigCircleRadius < mMinRadius && (mDistance > mBigCircleRadius))
                          || (mBigCircleRadius > mMaxRadius && (mDistance < mBigCircleRadius))) {
                          v.setScaleX(scale);
                          v.setScaleY(scale);
                          mBigCircleRadius = (int) mDistance;
                          mCircleThick = (int) (10 * scale);
                      }
                  } else {
                      newLeft = v.getLeft() + dX;
                      newTop = v.getTop() + dY;
                      newRight = v.getRight() + dX;
                      newBottom = v.getBottom() + dY;
                      v.layout(newLeft, newTop, newRight, newBottom);
                  }
                  lastX = lastX + dX;
                  lastY = lastY + dY;
                  }
                  break;
              case MotionEvent.ACTION_UP:
                  mCanResize = false;
                  mIsDrag = false;
                  if (v.getId() == R.id.rl_direction_key) {
                      mRlDirectionParams.leftMargin = newLeft;
                      mRlDirectionParams.topMargin = newTop;
                      mRlDirectionParams.rightMargin = newRight;
                      mRlDirectionParams.bottomMargin = newBottom;
                      mRlDirectionParams.setMargins(v.getLeft(), v.getTop(), v.getRight(), v.getBottom());
                      v.setLayoutParams(mRlDirectionParams);
                      v.getLocationOnScreen(mLocations);
                      mCircleCenterX = mLocations[0] + mBigCircleRadius;
                      mCircleCenterY = mLocations[1] + mBigCircleRadius;                   
                      int top = mTvUp.getPaddingTop();
                      int size = (int) mTvUp.getTextSize();
                      mDistanceFromCircleToKey = mBigCircleRadius - top;
                      ViewManager.mDirectionKeyArr[4] = mCircleCenterX;
                      ViewManager.mDirectionKeyArr[5] = mCircleCenterY;
                      ViewManager.mDirectionKeyArr[6] = mDistanceFromCircleToKey;
                  }
                  break;
             }
             return true;
         }
     }
``` 
- DirectionKeyHoverListener
``` 
  @Override
  public boolean onHover(View v, MotionEvent event) {
      switch (event.getAction()) {
          case MotionEvent.ACTION_HOVER_ENTER:
              if (mBigCircleRadius == 0) {
                  mBigCircleRadius = mRlDirectionKey.getWidth() / 2;
              }
              break;
          case MotionEvent.ACTION_HOVER_MOVE:
              if (!mIsDrag) {
                  mDistance = Math.pow(Math.abs(event.getRawX() - mCircleCenterX), 2)
                              + Math.pow(Math.abs(event.getRawY() - mCircleCenterY), 2);
                  if (mDistance <= Math.pow(mBigCircleRadius, 2)
                      && mDistance >= Math.pow(mBigCircleRadius - mCircleThick, 2)) {
                      mCanResize = true;
                  } else {
                      mCanResize = false;
                  }
              }
              break;
          case MotionEvent.ACTION_HOVER_EXIT:
              break;
      }
      return false;
  }
``` 
