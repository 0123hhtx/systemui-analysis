# 键盘映射

- 将键盘按键事件和手柄的摇杆按键事件转换为手机游戏的触摸事件，实现类似PC端的游戏体验。

## 总体设计
- 独立应用，提供键盘映射开启按钮；
- 开启后，在所有应用之上打开透明窗口：BaseView，用于接受所有按键事件；
- 快捷键F12打开半透明按键配置界面：ControlView2，用户可根据游戏需要添加轮盘、按钮控件；点击保存按钮关闭配置界面，并且配置生效；
- 关闭应用，同时关闭BaseView；

## 核心代码
### MainActivity.java
- 初始化mHandler，开启按钮，设置按钮点击事件，打开BaseView；

### ViewManager.java
- 打开BaseView：
``` 
  public void showBase() {
      hideControl();
      mBaseView = new BaseView(context);
      windowManager = 
          (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
      if (mBaseViewParams == null) {
          mBaseViewParams = new WindowManager.LayoutParams();
          mBaseViewParams.width = MainActivity.screenWidth;
          mBaseViewParams.height = MainActivity.screenHeight;
          mBaseViewParams.gravity = Gravity.TOP | Gravity.LEFT;
          mBaseViewParams.type = 
              WindowManager.LayoutParams.TYPE_SYSTEM_ALERT;
          mBaseViewParams.flags = 
              WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
          mBaseViewParams.format = PixelFormat.RGBA_8888;
      }
      windowManager.addView(mBaseView, mBaseViewParams);
  }
``` 

- 打开配置界面ControlView2，与BaseView同理；

### BaseView.java
- 自定义View，通过WindowManager.addView覆盖在所有应用之上的透明窗口，可以获取所有KeyEvent事件；
- 拦截按键事件，并发送模拟点击；
``` 
@Override
public boolean dispatchKeyEvent(final KeyEvent event) {
// 接收按键F12，打开ControlView2
    ......

if (event.getAction() == KeyEvent.ACTION_DOWN
        && event.getRepeatCount() == 0) {
    if (mDirectionKeys.contains(keyCode)) {
        if ((mCurrentDirectionX < mCircleCenterX - mDistanceFromCircleToKey)
            || (mCurrentDirectionX > mCircleCenterX + mDistanceFromCircleToKey)
            || (mCurrentDirectionY < mCircleCenterY - mDistanceFromCircleToKey)
            || (mCurrentDirectionY > 
                mCircleCenterY + mDistanceFromCircleToKey)) 
            mCurrentDirectionX = 0;
            mCurrentDirectionY = 0;
            mPressedDirectionKeyCount = 0;
        }
        mPressedDirectionKeyCount++;
        if (mPressedDirectionKeyCount == 1) {
            // todo down circle center
            mCircleCenterX = mDirectionKeys.get(4);
            mCircleCenterY = mDirectionKeys.get(5);
            mDistanceFromCircleToKey = mDirectionKeys.get(6);
            mCurrentDirectionX = mCircleCenterX;
            mCurrentDirectionY = mCircleCenterY;
        }
        // 处理轮盘点击方向
        if (event.getKeyCode() == mDirectionKeys.get(0)) {
            // 按键对应轮盘方向：左
            mCurrentDirectionX = mCurrentDirectionX - mDistanceFromCircleToKey;
        } else  if (event.getKeyCode() == mDirectionKeys.get(1)) {
            // 按键对应轮盘方向：上
            mCurrentDirectionY = mCurrentDirectionY - mDistanceFromCircleToKey;
        } else  if (event.getKeyCode() == mDirectionKeys.get(2)) {
            // 按键对应轮盘方向：右
            mCurrentDirectionX = mCurrentDirectionX + mDistanceFromCircleToKey;
        } else  if (event.getKeyCode() == mDirectionKeys.get(3)) {
            // 按键对应轮盘方向：下
            mCurrentDirectionY = mCurrentDirectionY + mDistanceFromCircleToKey;
        }
            if (mPressedDirectionKeyCount == 1) {
                processDirectionKeyMapping(mInstrumentation, MotionEvent.ACTION_MOVE, mCurrentDirectionX, mCurrentDirectionY, true,mCircleCenterX, mCircleCenterY);
          } else {
              processDirectionKeyMapping(mInstrumentation, MotionEvent.ACTION_MOVE,
              mCurrentDirectionX, mCurrentDirectionY, false, 0, 0);
          }
      } else if (mFunctionKeys.contains(event.getKeyCode())) {
          // todo down functionkey
          int index = mFunctionKeys.indexOf(keyCode);
          if (mPressedDirectionKeyCount == 0) {
              processFunctionKeyMapping(mInstrumentation, MotionEvent.ACTION_DOWN,
              ViewManager.mDragViewList.get(index).mWUpX + 45,
              ViewManager.mDragViewList.get(index).mWUpY + 45, false, 0, 0 , 0, 0);
          } else {
              processFunctionKeyMapping(mInstrumentation, MotionEvent.ACTION_DOWN,
              ViewManager.mDragViewList.get(index).mWUpX + 45, ViewManager.mDragViewList.get(index).mWUpY + 45, true, mCircleCenterX, mCircleCenterY, mCurrentDirectionX, mCurrentDirectionY);
          }
      }
  } else if (event.getAction() == KeyEvent.ACTION_UP) {
      if (mDirectionKeys.contains(event.getKeyCode())) {
          mPressedDirectionKeyCount--;
          if ((mCurrentDirectionX < mCircleCenterX - mDistanceFromCircleToKey)
            || (mCurrentDirectionX > mCircleCenterX + mDistanceFromCircleToKey)
            || (mCurrentDirectionY < mCircleCenterY - mDistanceFromCircleToKey)
            || (mCurrentDirectionY > mCircleCenterY + mDistanceFromCircleToKey)) {
             mCurrentDirectionX = 0;
             mCurrentDirectionY = 0;
             mPressedDirectionKeyCount = 0;
          }
          // todo move direction
          if (event.getKeyCode() == mDirectionKeys.get(0)) {
              // direction left
              mCurrentDirectionX = mCurrentDirectionX + mDistanceFromCircleToKey;
          } else  if (event.getKeyCode() == mDirectionKeys.get(1)) {
              // direction up
              mCurrentDirectionY = mCurrentDirectionY + mDistanceFromCircleToKey;
         } else  if (event.getKeyCode() == mDirectionKeys.get(2)) {
             // direction right
             mCurrentDirectionX = mCurrentDirectionX - mDistanceFromCircleToKey;
         } else  if (event.getKeyCode() == mDirectionKeys.get(3)) {
             // direction down
             mCurrentDirectionY = mCurrentDirectionY - mDistanceFromCircleToKey;
         }
         if (mPressedDirectionKeyCount == 0) {
             processDirectionKeyMapping(mInstrumentation, MotionEvent.ACTION_UP,
             mCurrentDirectionX, mCurrentDirectionY, false, 0, 0);
         } else {
             processDirectionKeyMapping(mInstrumentation, MotionEvent.ACTION_MOVE,
             mCurrentDirectionX, mCurrentDirectionY, false, 0, 0);
         }
    } else if (mFunctionKeys.contains(event.getKeyCode())) {
        // todo up functionkey
        int index = mFunctionKeys.indexOf(keyCode);
        if (mPressedDirectionKeyCount == 0) {
            processFunctionKeyMapping(mInstrumentation, MotionEvent.ACTION_UP, ViewManager.mDragViewList.get(index).mWUpX + 45, ViewManager.mDragViewList.get(index).mWUpY + 45, false, 0, 0 , 0, 0);
        } else {
            processFunctionKeyMapping(mInstrumentation, MotionEvent.ACTION_UP, ViewManager.mDragViewList.get(index).mWUpX + 45, ViewManager.mDragViewList.get(index).mWUpY + 45, true, mCircleCenterX, mCircleCenterY , mCurrentDirectionX, mCurrentDirectionY);
        }
    }
}
return super.dispatchKeyEvent(event);
}
``` 
- 处理接收到的轮盘方向键：
``` 
public void processDirectionKeyMapping(final Instrumentation in, final int eventType, 
                             final float x, final float y, final boolean needDown,
                             final float downX, final float downY) {
new Thread() {
       @Override
       public void run() {
           super.run();
           long time = SystemClock.uptimeMillis();
           // 模拟点击轮盘方向键
           if (needDown) {
               in.sendPointerSync(MotionEvent.obtain(time, time,
                                 MotionEvent.ACTION_DOWN, downX, downY, 0));
               in.sendPointerSync(MotionEvent.obtain(time, time, eventType, x, y, 0));
           } else {
               in.sendPointerSync(MotionEvent.obtain(time, time, eventType, x, y, 0));
           }
        }
    }.start();
}
``` 
- 处理接收到的功能键：
``` 
  public void processFunctionKeyMapping(final Instrumentation in, final int eventType,
                   final float x, final float y, final boolean needMove, final float downX, 
                   final float downY, final float moveX, final float moveY) {
      new Thread() {
          @Override
          public void run() {
              super.run();
              long time = SystemClock.uptimeMillis();
              // 模拟点击功能键
              if (needMove) {
                  in.sendPointerSync(MotionEvent.obtain(time, time, eventType, x, y, 0));
                  in.sendPointerSync(MotionEvent.obtain(time, time, 
                                    MotionEvent.ACTION_DOWN, downX, downY, 0));
                  in.sendPointerSync(MotionEvent.obtain(time, time, 
                                    MotionEvent.ACTION_MOVE, moveX, moveY, 0));
              } else {
                  in.sendPointerSync(MotionEvent.obtain(time, time, eventType, x, y, 0));
              }
          }
      }.start();
  }
``` 

### ControlView2.java
- onAttachedToWindow
- buildBitmap
- createNewDragView
- DragView
- dispatchKeyEvent
- DirectionKeyTouchListener
- DirectionKeyHoverListener
